import { request } from '../request';
import { isRoutesRequest, isStep } from '../typeguards';
import { ValidationError } from '../utils/errors';
import { parseBackendError } from '../utils/parseError';
import ConfigService from './ConfigService';
const getPossibilities = async (requestConfig, options) => {
    if (!requestConfig) {
        requestConfig = {};
    }
    const config = ConfigService.getInstance().getConfig();
    // apply defaults
    if (requestConfig.bridges || config.defaultRouteOptions.bridges) {
        requestConfig.bridges =
            requestConfig.bridges || config.defaultRouteOptions.bridges;
    }
    if (requestConfig.exchanges || config.defaultRouteOptions.exchanges) {
        requestConfig.exchanges =
            requestConfig.exchanges || config.defaultRouteOptions.exchanges;
    }
    // send request
    try {
        const response = await request(`${config.apiUrl}/advanced/possibilities`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestConfig),
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getToken = async (chain, token, options) => {
    if (!chain) {
        throw new ValidationError('Required parameter "chain" is missing.');
    }
    if (!token) {
        throw new ValidationError('Required parameter "token" is missing.');
    }
    const config = ConfigService.getInstance().getConfig();
    try {
        const response = await request(`${config.apiUrl}/token?${new URLSearchParams({
            chain,
            token,
        })}`, {
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getQuote = async (requestConfig, options) => {
    const config = ConfigService.getInstance().getConfig();
    // validation
    const requiredParameters = [
        'fromChain',
        'fromToken',
        'fromAddress',
        'fromAmount',
        'toChain',
        'toToken',
    ];
    requiredParameters.forEach((requiredParameter) => {
        if (!requestConfig[requiredParameter]) {
            throw new ValidationError(`Required parameter "${requiredParameter}" is missing.`);
        }
    });
    // apply defaults
    requestConfig.order = requestConfig.order || config.defaultRouteOptions.order;
    requestConfig.slippage =
        requestConfig.slippage || config.defaultRouteOptions.slippage;
    requestConfig.integrator =
        requestConfig.integrator || config.defaultRouteOptions.integrator;
    requestConfig.referrer =
        requestConfig.referrer || config.defaultRouteOptions.referrer;
    requestConfig.fee = requestConfig.fee || config.defaultRouteOptions.fee;
    requestConfig.allowBridges =
        requestConfig.allowBridges || config.defaultRouteOptions.bridges?.allow;
    requestConfig.denyBridges =
        requestConfig.denyBridges || config.defaultRouteOptions.bridges?.deny;
    requestConfig.preferBridges =
        requestConfig.preferBridges || config.defaultRouteOptions.bridges?.prefer;
    requestConfig.allowExchanges =
        requestConfig.allowExchanges || config.defaultRouteOptions.exchanges?.allow;
    requestConfig.denyExchanges =
        requestConfig.denyExchanges || config.defaultRouteOptions.exchanges?.deny;
    requestConfig.preferExchanges =
        requestConfig.preferExchanges ||
            config.defaultRouteOptions.exchanges?.prefer;
    Object.keys(requestConfig).forEach((key) => !requestConfig[key] &&
        delete requestConfig[key]);
    try {
        const response = await request(`${config.apiUrl}/quote?${new URLSearchParams(requestConfig)}`, {
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getContractCallQuote = async (requestConfig, options) => {
    const config = ConfigService.getInstance().getConfig();
    // validation
    const requiredParameters = [
        'fromChain',
        'fromToken',
        'fromAddress',
        'toChain',
        'toToken',
        'toAmount',
        'toContractAddress',
        'toContractCallData',
        'toContractGasLimit',
    ];
    requiredParameters.forEach((requiredParameter) => {
        if (!requestConfig[requiredParameter]) {
            throw new ValidationError(`Required parameter "${requiredParameter}" is missing.`);
        }
    });
    // apply defaults
    // option.order is not used in this endpoint
    requestConfig.slippage =
        requestConfig.slippage || config.defaultRouteOptions.slippage;
    requestConfig.integrator =
        requestConfig.integrator || config.defaultRouteOptions.integrator;
    requestConfig.referrer =
        requestConfig.referrer || config.defaultRouteOptions.referrer;
    requestConfig.fee = requestConfig.fee || config.defaultRouteOptions.fee;
    requestConfig.allowBridges =
        requestConfig.allowBridges || config.defaultRouteOptions.bridges?.allow;
    requestConfig.denyBridges =
        requestConfig.denyBridges || config.defaultRouteOptions.bridges?.deny;
    requestConfig.preferBridges =
        requestConfig.preferBridges || config.defaultRouteOptions.bridges?.prefer;
    requestConfig.allowExchanges =
        requestConfig.allowExchanges || config.defaultRouteOptions.exchanges?.allow;
    requestConfig.denyExchanges =
        requestConfig.denyExchanges || config.defaultRouteOptions.exchanges?.deny;
    requestConfig.preferExchanges =
        requestConfig.preferExchanges ||
            config.defaultRouteOptions.exchanges?.prefer;
    // send request
    try {
        const response = await request(`${config.apiUrl}/quote/contractCall`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestConfig),
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getStatus = async (requestConfig, options) => {
    if (!requestConfig.txHash) {
        throw new ValidationError('Required parameter "txHash" is missing.');
    }
    const config = ConfigService.getInstance().getConfig();
    const queryParams = new URLSearchParams(requestConfig);
    try {
        const response = await request(`${config.apiUrl}/status?${queryParams}`, {
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getChains = async (options) => {
    const config = ConfigService.getInstance().getConfig();
    try {
        const response = await request(`${config.apiUrl}/chains`, {
            signal: options?.signal,
        });
        return response.chains;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getRoutes = async (requestConfig, options) => {
    if (!isRoutesRequest(requestConfig)) {
        throw new ValidationError('Invalid routes request.');
    }
    const config = ConfigService.getInstance().getConfig();
    // apply defaults
    requestConfig.options = {
        ...config.defaultRouteOptions,
        ...requestConfig.options,
    };
    // send request
    try {
        const response = await request(`${config.apiUrl}/advanced/routes`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestConfig),
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getStepTransaction = async (step, options) => {
    if (!isStep(step)) {
        // While the validation fails for some users we should not enforce it
        // eslint-disable-next-line no-console
        console.warn('SDK Validation: Invalid Step', step);
    }
    const config = ConfigService.getInstance().getConfig();
    try {
        const response = await request(`${config.apiUrl}/advanced/stepTransaction`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(step),
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getTools = async (requestConfig, options) => {
    const config = ConfigService.getInstance().getConfig();
    if (requestConfig) {
        Object.keys(requestConfig).forEach((key) => !requestConfig[key] &&
            delete requestConfig[key]);
    }
    const response = await request(`${config.apiUrl}/tools?${new URLSearchParams(requestConfig)}`, {
        signal: options?.signal,
    });
    return response;
};
const getTokens = async (requestConfig, options) => {
    const config = ConfigService.getInstance().getConfig();
    if (requestConfig) {
        Object.keys(requestConfig).forEach((key) => !requestConfig[key] &&
            delete requestConfig[key]);
    }
    const response = await request(`${config.apiUrl}/tokens?${new URLSearchParams(requestConfig)}`, {
        signal: options?.signal,
    });
    return response;
};
const getGasRecommendation = async ({ chainId, fromChain, fromToken }, options) => {
    const config = ConfigService.getInstance().getConfig();
    if (!chainId) {
        throw new ValidationError('Required parameter "chainId" is missing.');
    }
    const url = new URL(`${config.apiUrl}/gas/suggestion/${chainId}`);
    if (fromChain) {
        url.searchParams.append('fromChain', fromChain);
    }
    if (fromToken) {
        url.searchParams.append('fromToken', fromToken);
    }
    try {
        const response = await request(url, {
            signal: options?.signal,
        });
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
const getAvailableConnections = async (connectionRequest) => {
    const config = ConfigService.getInstance().getConfig();
    const url = new URL(`${config.apiUrl}/connections`);
    const { fromChain, fromToken, toChain, toToken, allowBridges } = connectionRequest;
    if (fromChain) {
        url.searchParams.append('fromChain', fromChain);
    }
    if (fromToken) {
        url.searchParams.append('fromToken', fromToken);
    }
    if (toChain) {
        url.searchParams.append('fromToken', toChain);
    }
    if (toToken) {
        url.searchParams.append('fromToken', toToken);
    }
    if (allowBridges?.length) {
        allowBridges.forEach((bridge) => {
            url.searchParams.append('allowBridges', bridge);
        });
    }
    try {
        const response = await request(url);
        return response;
    }
    catch (e) {
        throw await parseBackendError(e);
    }
};
export default {
    getChains,
    getContractCallQuote,
    getGasRecommendation,
    getPossibilities,
    getQuote,
    getRoutes,
    getStatus,
    getStepTransaction,
    getToken,
    getTokens,
    getTools,
    getAvailableConnections,
};
