import { Route } from '@lifi/types';
import { Signer } from 'ethers';
import ConfigService from '../services/ConfigService';
import { ConfigUpdate, ExecutionSettings } from '../types';
export declare class RouteExecutionManager {
    private executionDictionary;
    private executionPromiseDictionary;
    protected configService: ConfigService;
    constructor(configUpdate?: ConfigUpdate);
    /**
     * Execute a route.
     * @param {Signer} signer - The signer required to send the transactions.
     * @param {Route} route - The route that should be executed. Cannot be an active route.
     * @param {ExecutionSettings} settings - An object containing settings and callbacks.
     * @return {Promise<Route>} The executed route.
     * @throws {LifiError} Throws a LifiError if the execution fails.
     */
    executeRoute: (signer: Signer, route: Route, settings?: ExecutionSettings) => Promise<Route>;
    /**
     * Resume the execution of a route that has been stopped or had an error while executing.
     * @param {Signer} signer - The signer required to send the transactions.
     * @param {Route} route - The route that is to be executed. Cannot be an active route.
     * @param {ExecutionSettings} settings - An object containing settings and callbacks.
     * @return {Promise<Route>} The executed route.
     * @throws {LifiError} Throws a LifiError if the execution fails.
     */
    resumeRoute: (signer: Signer, route: Route, settings?: ExecutionSettings) => Promise<Route>;
    private executeSteps;
    /**
     * Updates route execution to background or foreground state.
     * @param {Route} route - A route that is currently in execution.
     * @param {boolean} settings - An object with execution settings.
     */
    updateRouteExecution: (route: Route, settings: Pick<ExecutionSettings, 'executeInBackground'>) => void;
    /**
     * Update the ExecutionSettings for an active route.
     * @param {ExecutionSettings} settings - An object with execution settings.
     * @param {Route} route - The active route that gets the new execution settings.
     * @throws {ValidationError} Throws a ValidationError if parameters are invalid.
     */
    updateExecutionSettings: (settings: ExecutionSettings, route: Route) => void;
    /**
     * Executes a route until a user interaction is necessary (signing transactions, etc.) and then halts until the route is resumed.
     * @param {Route} route - A route that is currently in execution.
     * @deprecated use updateRouteExecution instead.
     */
    moveExecutionToBackground: (route: Route) => void;
    /**
     * Stops the execution of an active route.
     * @param {Route} route - A route that is currently in execution.
     * @return {Route} The stopped route.
     */
    stopExecution: (route: Route) => Route;
    /**
     * Get the list of active routes.
     * @return {Route[]} A list of routes.
     */
    getActiveRoutes: () => Route[];
    /**
     * Return the current route information for given route. The route has to be active.
     * @param {Route} route - A route object.
     * @return {Route} The updated route.
     */
    getActiveRoute: (route: Route) => Route | undefined;
}
