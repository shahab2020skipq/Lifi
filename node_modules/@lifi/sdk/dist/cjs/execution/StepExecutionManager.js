"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StepExecutionManager = void 0;
const allowance_1 = require("../allowance");
const balance_1 = require("../balance");
const ApiService_1 = __importDefault(require("../services/ApiService"));
const ChainsService_1 = __importDefault(require("../services/ChainsService"));
const errors_1 = require("../utils/errors");
const getProvider_1 = require("../utils/getProvider");
const parseError_1 = require("../utils/parseError");
const utils_1 = require("../utils/utils");
const stepComparison_1 = require("./stepComparison");
const switchChain_1 = require("./switchChain");
const utils_2 = require("./utils");
class StepExecutionManager {
    constructor() {
        this.allowUserInteraction = true;
        this.allowInteraction = (value) => {
            this.allowUserInteraction = value;
        };
        this.execute = async ({ signer, step, statusManager, settings, }) => {
            step.execution = statusManager.initExecutionObject(step);
            const chainsService = ChainsService_1.default.getInstance();
            const fromChain = await chainsService.getChainById(step.action.fromChainId);
            const toChain = await chainsService.getChainById(step.action.toChainId);
            const isBridgeExecution = fromChain.id !== toChain.id;
            const currentProcessType = isBridgeExecution ? 'CROSS_CHAIN' : 'SWAP';
            // STEP 1: Check allowance
            const existingProcess = step.execution.process.find((p) => p.type === currentProcessType);
            // Check token approval only if fromToken is not the native token => no approval needed in that case
            if (!existingProcess?.txHash &&
                !(0, utils_1.isZeroAddress)(step.action.fromToken.address)) {
                await (0, allowance_1.checkAllowance)(signer, step, statusManager, settings, fromChain, this.allowUserInteraction);
            }
            // STEP 2: Get transaction
            let process = statusManager.findOrCreateProcess(step, currentProcessType);
            if (process.status !== 'DONE') {
                try {
                    let transaction;
                    if (process.txHash) {
                        // Make sure that the chain is still correct
                        const updatedSigner = await (0, switchChain_1.switchChain)(signer, statusManager, step, settings.switchChainHook, this.allowUserInteraction);
                        if (!updatedSigner) {
                            // Chain switch was not successful, stop execution here
                            return step.execution;
                        }
                        signer = updatedSigner;
                        // Load exiting transaction
                        transaction = await (0, getProvider_1.getProvider)(signer).getTransaction(process.txHash);
                    }
                    else {
                        process = statusManager.updateProcess(step, process.type, 'STARTED');
                        // Check balance
                        await (0, balance_1.checkBalance)(signer, step);
                        // Create new transaction
                        if (!step.transactionRequest) {
                            const personalizedStep = await (0, utils_1.personalizeStep)(signer, step);
                            const updatedStep = await ApiService_1.default.getStepTransaction(personalizedStep);
                            const comparedStep = await (0, stepComparison_1.stepComparison)(statusManager, personalizedStep, updatedStep, settings, this.allowUserInteraction);
                            step = {
                                ...comparedStep,
                                execution: step.execution,
                            };
                        }
                        const { transactionRequest } = step;
                        if (!transactionRequest) {
                            throw new errors_1.TransactionError(errors_1.LifiErrorCode.TransactionUnprepared, 'Unable to prepare transaction.');
                        }
                        // STEP 3: Send the transaction
                        // Make sure that the chain is still correct
                        const updatedSigner = await (0, switchChain_1.switchChain)(signer, statusManager, step, settings.switchChainHook, this.allowUserInteraction);
                        if (!updatedSigner) {
                            // Chain switch was not successful, stop execution here
                            return step.execution;
                        }
                        signer = updatedSigner;
                        process = statusManager.updateProcess(step, process.type, 'ACTION_REQUIRED');
                        if (!this.allowUserInteraction) {
                            return step.execution;
                        }
                        if (settings.updateTransactionRequest) {
                            const customConfig = await settings.updateTransactionRequest(transactionRequest);
                            transactionRequest.gasLimit = customConfig.gasLimit;
                            transactionRequest.gasPrice = customConfig.gasPrice;
                            transactionRequest.maxPriorityFeePerGas =
                                customConfig.maxPriorityFeePerGas;
                            transactionRequest.maxFeePerGas = customConfig.maxFeePerGas;
                        }
                        // Submit the transaction
                        transaction = await signer.sendTransaction(transactionRequest);
                        // STEP 4: Wait for the transaction
                        process = statusManager.updateProcess(step, process.type, 'PENDING', {
                            txHash: transaction.hash,
                            txLink: fromChain.metamask.blockExplorerUrls[0] +
                                'tx/' +
                                transaction.hash,
                        });
                    }
                    await transaction.wait();
                    process = statusManager.updateProcess(step, process.type, 'PENDING', {
                        txHash: transaction.hash,
                        txLink: fromChain.metamask.blockExplorerUrls[0] + 'tx/' + transaction.hash,
                    });
                    if (isBridgeExecution) {
                        process = statusManager.updateProcess(step, process.type, 'DONE');
                    }
                }
                catch (e) {
                    if (e.code === 'TRANSACTION_REPLACED' && e.replacement) {
                        process = statusManager.updateProcess(step, process.type, 'DONE', {
                            txHash: e.replacement.hash,
                            txLink: fromChain.metamask.blockExplorerUrls[0] +
                                'tx/' +
                                e.replacement.hash,
                        });
                    }
                    else {
                        const error = await (0, parseError_1.parseError)(e, step, process);
                        process = statusManager.updateProcess(step, process.type, 'FAILED', {
                            error: {
                                message: error.message,
                                htmlMessage: error.htmlMessage,
                                code: error.code,
                            },
                        });
                        statusManager.updateExecution(step, 'FAILED');
                        throw error;
                    }
                }
            }
            // STEP 5: Wait for the receiving chain
            const processTxHash = process.txHash;
            if (isBridgeExecution) {
                process = statusManager.findOrCreateProcess(step, 'RECEIVING_CHAIN', 'PENDING');
            }
            let statusResponse;
            try {
                if (!processTxHash) {
                    throw new Error('Transaction hash is undefined.');
                }
                statusResponse = await (0, utils_2.waitForReceivingTransaction)(processTxHash, statusManager, process.type, step);
                process = statusManager.updateProcess(step, process.type, 'DONE', {
                    substatus: statusResponse.substatus,
                    substatusMessage: statusResponse.substatusMessage ||
                        (0, utils_2.getSubstatusMessage)(statusResponse.status, statusResponse.substatus),
                    txHash: statusResponse.receiving?.txHash,
                    txLink: toChain.metamask.blockExplorerUrls[0] +
                        'tx/' +
                        statusResponse.receiving?.txHash,
                });
                statusManager.updateExecution(step, 'DONE', {
                    fromAmount: statusResponse.sending.amount,
                    toAmount: statusResponse.receiving?.amount,
                    toToken: statusResponse.receiving?.token,
                    gasAmount: statusResponse.sending.gasAmount,
                    gasAmountUSD: statusResponse.sending.gasAmountUSD,
                    gasPrice: statusResponse.sending.gasPrice,
                    gasToken: statusResponse.sending.gasToken,
                    gasUsed: statusResponse.sending.gasUsed,
                });
            }
            catch (e) {
                const htmlMessage = await (0, parseError_1.getTransactionFailedMessage)(step, process.txLink);
                process = statusManager.updateProcess(step, process.type, 'FAILED', {
                    error: {
                        code: errors_1.LifiErrorCode.TransactionFailed,
                        message: 'Failed while waiting for receiving chain.',
                        htmlMessage,
                    },
                });
                statusManager.updateExecution(step, 'FAILED');
                console.warn(e);
                throw e;
            }
            // DONE
            return step.execution;
        };
    }
}
exports.StepExecutionManager = StepExecutionManager;
