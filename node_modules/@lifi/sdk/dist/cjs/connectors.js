"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMulticallAddress = exports.getRpcProvider = exports.getRpcUrls = exports.getRpcUrl = void 0;
const ethers_1 = require("ethers");
const types_1 = require("./types");
const ConfigService_1 = __importDefault(require("./services/ConfigService"));
const helpers_1 = require("./helpers");
const errors_1 = require("./utils/errors");
// cached providers
const chainProviders = {};
// Archive RPC Provider
const archiveRpcs = {
    [types_1.ChainId.ETH]: 'https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/eth/mainnet/archive',
    [types_1.ChainId.BSC]: 'https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/bsc/mainnet/archive',
    [types_1.ChainId.POL]: 'https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/polygon/mainnet/archive',
    [types_1.ChainId.FTM]: 'https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/fantom/mainnet',
};
// RPC Urls
const getRpcUrl = async (chainId, archive = false) => {
    const rpcUrls = await (0, exports.getRpcUrls)(chainId, archive);
    return rpcUrls[0];
};
exports.getRpcUrl = getRpcUrl;
const getRpcUrls = async (chainId, archive = false) => {
    if (archive && archiveRpcs[chainId]) {
        return [archiveRpcs[chainId]];
    }
    const configService = ConfigService_1.default.getInstance();
    const config = await configService.getConfigAsync();
    return config.rpcs[chainId];
};
exports.getRpcUrls = getRpcUrls;
const getRandomProvider = (providerList) => {
    const index = (0, helpers_1.getRandomNumber)(0, providerList.length - 1);
    return providerList[index];
};
// Provider
const getRpcProvider = async (chainId, archive = false) => {
    if (archive && archiveRpcs[chainId]) {
        // return archive PRC, but don't cache it
        return new ethers_1.providers.FallbackProvider([
            new ethers_1.providers.StaticJsonRpcProvider(await (0, exports.getRpcUrl)(chainId, archive), chainId),
        ]);
    }
    if (!chainProviders[chainId]) {
        chainProviders[chainId] = [];
        const urls = await (0, exports.getRpcUrls)(chainId, archive);
        urls.forEach((url) => {
            chainProviders[chainId].push(new ethers_1.providers.FallbackProvider([
                new ethers_1.providers.StaticJsonRpcProvider(url, chainId),
            ]));
        });
    }
    if (!chainProviders[chainId].length) {
        throw new errors_1.ServerError(`Unable to configure provider for chain ${chainId}`);
    }
    return getRandomProvider(chainProviders[chainId]);
};
exports.getRpcProvider = getRpcProvider;
// Multicall
const getMulticallAddress = async (chainId) => {
    const configService = ConfigService_1.default.getInstance();
    const config = await configService.getConfigAsync();
    return config.multicallAddresses[chainId];
};
exports.getMulticallAddress = getMulticallAddress;
