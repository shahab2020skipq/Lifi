"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlePreRestart = void 0;
const errors_1 = require("./errors");
const handlePreRestart = (route) => {
    for (let index = 0; index < route.steps.length; index++) {
        const stepHasFailed = route.steps[index].execution?.status === 'FAILED';
        if (stepHasFailed) {
            handleErrorType(route, index);
            deleteFailedProcesses(route, index);
            deleteTransactionData(route, index);
        }
    }
};
exports.handlePreRestart = handlePreRestart;
const handleErrorType = (route, index) => {
    const isGasLimitError = route.steps[index].execution?.process.some((p) => p.error?.code === errors_1.LifiErrorCode.GasLimitError);
    const isGasPriceError = route.steps[index].execution?.process.some((p) => p.error?.code === errors_1.LifiErrorCode.TransactionUnderpriced);
    if (isGasLimitError) {
        route.steps[index].estimate.gasCosts?.forEach((gasCost) => (gasCost.limit = `${Math.round(Number(gasCost.limit) * 1.25)}`));
    }
    if (isGasPriceError) {
        route.steps[index].estimate.gasCosts?.forEach((gasCost) => (gasCost.price = `${Math.round(Number(gasCost.price) * 1.25)}`));
    }
};
const deleteFailedProcesses = (route, index) => {
    if (route.steps[index].execution) {
        route.steps[index].execution.process = route.steps[index].execution.process.filter((process) => process.status === 'DONE');
    }
};
const deleteTransactionData = (route, index) => {
    route.steps[index].transactionRequest = undefined;
};
