"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchDataUsingMulticall = void 0;
const abi_1 = require("@ethersproject/abi");
const contracts_1 = require("@ethersproject/contracts");
const connectors_1 = require("../connectors");
const utils_1 = require("./utils");
const multicallAbi_json_1 = __importDefault(require("./multicallAbi.json"));
const MAX_MULTICALL_SIZE = 100;
const fetchDataUsingMulticall = async (calls, abi, chainId, multicallAddress, requireSuccess = false) => {
    // 1. create contract using multicall contract address and abi...
    const provider = await (0, connectors_1.getRpcProvider)(chainId);
    const multicallContract = new contracts_1.Contract(multicallAddress, multicallAbi_json_1.default, provider);
    const abiInterface = new abi_1.Interface(abi);
    // split up lists into chunks to stay below multicall limit
    const chunkedList = (0, utils_1.splitListIntoChunks)(calls, MAX_MULTICALL_SIZE);
    const chunkedResults = await Promise.all(chunkedList.map(async (chunkedCalls) => {
        const callData = chunkedCalls.map((call) => [
            call.address.toLowerCase(),
            abiInterface.encodeFunctionData(call.name, call.params),
        ]);
        try {
            // 3. get bytes array from multicall contract by process aggregate method...
            const { blockNumber, returnData } = await multicallContract.tryBlockAndAggregate(requireSuccess, callData);
            // 4. decode bytes array to useful data array...
            return returnData
                .map(({ success, returnData }, i) => {
                if (!success) {
                    // requested function failed
                    console.error(`Multicall unsuccessful for address "${chunkedCalls[i].address}", ` +
                        `function "${chunkedCalls[i].name}", chainId "${chainId}"`);
                    return [];
                }
                if (returnData.toString() === '0x') {
                    // requested function does probably not exist
                    console.error(`Multicall no response for address "${chunkedCalls[i].address}", ` +
                        `function "${chunkedCalls[i].name}", chainId "${chainId}"`);
                    return [];
                }
                try {
                    return abiInterface.decodeFunctionResult(chunkedCalls[i].name, returnData);
                }
                catch (e) {
                    // requested function returns other data than expected
                    console.error(`Multicall parsing unsuccessful for address "${chunkedCalls[i].address}", ` +
                        `function "${chunkedCalls[i].name}", chainId "${chainId}"`);
                    return [];
                }
            })
                .map((data) => {
                return {
                    data: data[0],
                    blockNumber: blockNumber.toNumber(),
                };
            });
        }
        catch (e) {
            // whole rpc call failed, probably an rpc issue
            console.error(`Multicall failed on chainId "${chainId}"`, chunkedList, e);
            return [];
        }
    }));
    return chunkedResults.flat();
};
exports.fetchDataUsingMulticall = fetchDataUsingMulticall;
