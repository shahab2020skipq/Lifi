"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseBackendError = exports.parseError = exports.getTransactionFailedMessage = exports.getTransactionNotSentMessage = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const ChainsService_1 = __importDefault(require("../services/ChainsService"));
const errors_1 = require("./errors");
const utils_1 = require("./utils");
/**
 * Available MetaMask error codes:
 *
 * export const errorCodes: ErrorCodes = {
     rpc: {
      invalidInput: -32000,
      resourceNotFound: -32001,
      resourceUnavailable: -32002,
      transactionRejected: -32003,
      methodNotSupported: -32004,
      limitExceeded: -32005,
      parse: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internal: -32603,
    },
    provider: {
      userRejectedRequest: 4001,
      unauthorized: 4100,
      unsupportedMethod: 4200,
      disconnected: 4900,
      chainDisconnected: 4901,
    },
  };
 *
 * For more information about error codes supported by metamask check
 * https://github.com/MetaMask/eth-rpc-errors
 * https://eips.ethereum.org/EIPS/eip-1474#error-codes
 * https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */
const getTransactionNotSentMessage = async (step, process) => {
    let transactionNotSend = 'Transaction was not sent, your funds are still in your wallet';
    // add information about funds if available
    if (step) {
        const chainService = ChainsService_1.default.getInstance();
        const chain = await chainService.getChainById(step.action.fromChainId);
        transactionNotSend += ` (${(0, utils_1.formatTokenAmountOnly)(step.action.fromToken, step.action.fromAmount)} ${step.action.fromToken.symbol} on ${chain.name})`;
    }
    transactionNotSend +=
        ", please retry.<br/>If it still doesn't work, it is safe to delete this transfer and start a new one.";
    // add transaction explorer link if available
    transactionNotSend +=
        process && process.txLink
            ? `<br>You can check the failed transaction&nbsp;<a href="${process.txLink}" target="_blank" rel="nofollow noreferrer">here</a>.`
            : '';
    return transactionNotSend;
};
exports.getTransactionNotSentMessage = getTransactionNotSentMessage;
const getTransactionFailedMessage = async (step, txLink) => {
    const chainsService = ChainsService_1.default.getInstance();
    const chain = await chainsService.getChainById(step.action.toChainId);
    const baseString = `It appears that your transaction may not have been successful.
  However, to confirm this, please check your ${chain.name} wallet for ${step.action.toToken.symbol}.`;
    return txLink
        ? `${baseString}
    You can also check the&nbsp;<a href="${txLink}" target="_blank" rel="nofollow noreferrer">block explorer</a> for more information.`
        : baseString;
};
exports.getTransactionFailedMessage = getTransactionFailedMessage;
const parseError = async (e, step, process) => {
    if (e instanceof errors_1.LifiError) {
        return e;
    }
    if (e.code) {
        // MetaMask errors have a numeric error code
        if (typeof e.code === 'number') {
            if (Object.values(eth_rpc_errors_1.errorCodes.rpc).includes(e.code)) {
                // rpc errors
                // underpriced errors are sent as internal errors, so we need to parse the message manually
                if (e.code === eth_rpc_errors_1.errorCodes.rpc.internal &&
                    (e.message?.includes(errors_1.EthersErrorMessage.Underpriced) ||
                        e.message?.includes(errors_1.EthersErrorMessage.LowReplacementFee))) {
                    return new errors_1.RPCError(errors_1.LifiErrorCode.TransactionUnderpriced, errors_1.ErrorMessage.TransactionUnderpriced, await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
                }
                if (e.message?.includes(errors_1.EthersErrorMessage.LowGas) ||
                    e.message?.includes(errors_1.EthersErrorMessage.OutOfGas)) {
                    return new errors_1.TransactionError(errors_1.LifiErrorCode.GasLimitError, errors_1.ErrorMessage.GasLimitLow, await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
                }
                return new errors_1.RPCError(e.code, (0, eth_rpc_errors_1.getMessageFromCode)(e.code), await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
            }
            // provider errors
            if (Object.values(eth_rpc_errors_1.errorCodes.provider).includes(e.code)) {
                return new errors_1.ProviderError(e.code, (0, eth_rpc_errors_1.getMessageFromCode)(e.code), await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
            }
        }
    }
    switch (e.code) {
        case errors_1.EthersErrorType.CallExecption:
            if (e.reason?.includes?.includes(errors_1.EthersErrorMessage.ERC20Allowance)) {
                return new errors_1.TransactionError(errors_1.LifiErrorCode.AllowanceRequired, e.reason, await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
            }
            return new errors_1.ProviderError(errors_1.LifiErrorCode.TransactionFailed, e.reason, await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
        case errors_1.EthersErrorType.ActionRejected:
        case errors_1.MetaMaskProviderErrorCode.userRejectedRequest:
            return new errors_1.TransactionError(errors_1.LifiErrorCode.TransactionRejected, e.message, await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
        case errors_1.LifiErrorCode.TransactionUnprepared:
            return new errors_1.TransactionError(errors_1.LifiErrorCode.TransactionUnprepared, e.message, await (0, exports.getTransactionNotSentMessage)(step, process), e.stack);
        case errors_1.LifiErrorCode.ValidationError:
            return new errors_1.TransactionError(errors_1.LifiErrorCode.ValidationError, e.message, e.htmlMessage);
        default:
            return new errors_1.UnknownError(errors_1.LifiErrorCode.InternalError, e.message || errors_1.ErrorMessage.UnknownError, undefined, e.stack);
    }
};
exports.parseError = parseError;
const parseBackendError = async (e) => {
    let data;
    try {
        data = await e.response?.json();
    }
    catch (error) {
        // ignore
    }
    if (e.response?.status === 400) {
        return new errors_1.ValidationError(data?.message || e.response?.statusText, undefined, e.stack);
    }
    if (e.response?.status === 404) {
        return new errors_1.NotFoundError(data?.message || e.response?.statusText, undefined, e.stack);
    }
    if (e.response?.status === 409) {
        return new errors_1.SlippageError(data?.message || e.response?.statusText, errors_1.ErrorMessage.SlippageError, e.stack);
    }
    if (e.response?.status === 500) {
        return new errors_1.ServerError(data?.message || e.response?.statusText, undefined, e.stack);
    }
    return new errors_1.ServerError(errors_1.ErrorMessage.Default, undefined, e.stack);
};
exports.parseBackendError = parseBackendError;
// const fetchTxErrorDetails = async (txHash: string, chainId: number) => {
//   const response = await request<TenderlyResponse>(
//     `https://api.tenderly.co/api/v1/public-contract/${chainId}/tx/${txHash}`,
//     undefined,
//     0
//   )
//   return response
// }
