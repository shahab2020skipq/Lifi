"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertQuoteToRoute = exports.checkPackageUpdates = exports.isSameToken = exports.getRandomNumber = exports.getEthereumPublicKeyHook = exports.getEthereumDecryptionHook = void 0;
const request_1 = require("./request");
const errors_1 = require("./utils/errors");
const version_1 = require("./version");
const ethereumRequest = async (method, params) => {
    // If ethereum.request() exists, the provider is probably EIP-1193 compliant.
    if (!ethereum?.request) {
        throw new Error('Provider not available.');
    }
    return ethereum.request({
        method,
        params,
    });
};
/**
 * Predefined hook that decrypts calldata using EIP-1193 compliant wallet functions.
 * @param {string} walletAddress - The wallet address of the user that should decrypt the calldata.
 * @return {(encryptedData: string) => Promise<any>} A function that decrypts data using EIP-1193 compliant wallet functions.
 */
const getEthereumDecryptionHook = (walletAddress) => {
    return (encryptedData) => {
        return ethereumRequest('eth_decrypt', [encryptedData, walletAddress]);
    };
};
exports.getEthereumDecryptionHook = getEthereumDecryptionHook;
/**
 * Predefined hook that get the public encryption key of a user using EIP-1193 compliant wallet functions.
 * @param {string} walletAddress - The wallet address of the user.
 * @return {(walletAddress: string) => () => Promise<any>} A function that return the public encryption key using EIP-1193 compliant wallet functions.
 */
const getEthereumPublicKeyHook = (walletAddress) => {
    return () => {
        return ethereumRequest('eth_getEncryptionPublicKey', [walletAddress]);
    };
};
exports.getEthereumPublicKeyHook = getEthereumPublicKeyHook;
/**
 * Returns a random number between min (inclusive) and max (inclusive)
 */
const getRandomNumber = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1) + min);
};
exports.getRandomNumber = getRandomNumber;
const isSameToken = (tokenA, tokenB) => tokenA.chainId === tokenB.chainId &&
    tokenA.address.toLowerCase() === tokenB.address.toLowerCase();
exports.isSameToken = isSameToken;
function semverCompare(a, b) {
    if (a.startsWith(b + '-')) {
        return -1;
    }
    if (b.startsWith(a + '-')) {
        return 1;
    }
    return a.localeCompare(b, undefined, {
        numeric: true,
        sensitivity: 'case',
        caseFirst: 'upper',
    });
}
const checkPackageUpdates = async (packageName, packageVersion, disableCheck) => {
    if (disableCheck || process.env.NODE_ENV !== 'development') {
        return;
    }
    try {
        const pkgName = packageName ?? version_1.name;
        const response = await (0, request_1.request)(`https://registry.npmjs.org/${pkgName}/latest`, { skipTrackingHeaders: true });
        const latestVersion = response.version;
        const currentVersion = packageVersion ?? version_1.version;
        if (semverCompare(latestVersion, currentVersion)) {
            console.warn(
            // eslint-disable-next-line max-len
            `${pkgName}: new package version is available. Please update as soon as possible to enjoy the newest features. Current version: ${currentVersion}. Latest version: ${latestVersion}.`);
        }
    }
    catch (error) {
        // Cannot verify version, might be network error etc. We don't bother showing anything in that case
    }
};
exports.checkPackageUpdates = checkPackageUpdates;
/**
 * Converts a quote to Route
 * @param {LifiStep} step - Step returned from the quote endpoint.
 * @return {Route} - The route to be executed.
 * @throws {ValidationError} Throws a ValidationError if the step has missing values.
 */
const convertQuoteToRoute = (step) => {
    if (!step.estimate.fromAmountUSD) {
        throw new errors_1.ValidationError("Missing 'fromAmountUSD' in step estimate.");
    }
    if (!step.estimate.toAmountUSD) {
        throw new errors_1.ValidationError("Missing 'toAmountUSD' in step estimate.");
    }
    const route = {
        fromToken: step.action.fromToken,
        toToken: step.action.toToken,
        fromAmount: step.action.fromAmount,
        toAmount: step.estimate.toAmount,
        id: step.id,
        fromChainId: step.action.fromToken.chainId,
        toChainId: step.action.toToken.chainId,
        fromAmountUSD: step.estimate.fromAmountUSD,
        toAmountUSD: step.estimate.toAmountUSD,
        steps: [step],
        toAmountMin: step.estimate.toAmountMin,
        insurance: { state: 'NOT_INSURABLE', feeAmountUsd: '0' },
    };
    return route;
};
exports.convertQuoteToRoute = convertQuoteToRoute;
