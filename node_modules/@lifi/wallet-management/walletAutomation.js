import { getChainById, MetaMaskProviderErrorCode, prefixChainId, } from '@lifi/sdk';
export const switchChain = async (provider, chainId) => {
    return new Promise((resolve, reject) => {
        try {
            provider
                .request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: getChainById(chainId).metamask?.chainId }],
            })
                .catch((error) => {
                if (error.code !== MetaMaskProviderErrorCode.userRejectedRequest) {
                    addChain(provider, chainId).then((result) => resolve(result));
                }
                else {
                    reject(error);
                }
            });
            provider.once('chainChanged', (id) => {
                if (parseInt(id) === chainId) {
                    resolve(true);
                }
            });
        }
        catch (error) {
            // const ERROR_CODE_UNKNOWN_CHAIN = 4902
            if (error.code !== MetaMaskProviderErrorCode.userRejectedRequest) {
                addChain(provider, chainId).then((result) => resolve(result));
            }
            else {
                console.error(error);
                resolve(false);
            }
        }
    });
};
export const addChain = async (provider, chainId) => {
    const params = getChainById(chainId).metamask;
    try {
        await provider.request({
            method: 'wallet_addEthereumChain',
            params: [params],
        });
        return true;
    }
    catch (error) {
        console.error(`Error adding chain ${chainId}: ${error.message}`);
    }
    return false;
};
export const addToken = async (provider, token) => {
    try {
        // wasAdded is a boolean. Like any RPC method, an error may be thrown.
        const wasAdded = await provider.request({
            method: 'wallet_watchAsset',
            params: {
                type: 'ERC20',
                options: {
                    address: token.address,
                    symbol: token.symbol,
                    decimals: token.decimals,
                    image: token.logoURI, // A string url of the token logo
                },
            },
        });
        return wasAdded;
    }
    catch (error) {
        console.error(error);
    }
    return false;
};
export const switchChainAndAddToken = async (provider, chainId, token) => {
    const chainIdPrefixed = prefixChainId(chainId);
    try {
        if (chainIdPrefixed !== provider.chainId) {
            await switchChain(provider, chainId);
            provider.once('chainChanged', async (id) => {
                if (parseInt(id, 10) === chainId) {
                    await addToken(provider, token);
                }
            });
        }
        else {
            await addToken(provider, token);
        }
        return true;
    }
    catch (e) {
        console.error(e);
        return false;
    }
};
