import WalletConnectProvider from '@walletconnect/ethereum-provider';
import { ethers } from 'ethers';
import events from 'events';
import { addChain, switchChain, switchChainAndAddToken, } from '../walletAutomation';
export class WalletConnectConnector extends events.EventEmitter {
    constructor(constructorArgs) {
        super();
        this.isActivationInProgress = false;
        this.options = constructorArgs.rpc;
        this.name = constructorArgs.name;
        this.icon = constructorArgs.icon;
        this.installed = constructorArgs.installed;
    }
    async startListening() {
        // Subscribe to accounts change
        this.provider?.on('accountsChanged', async (accounts) => {
            if (!accounts.length) {
                this.account = undefined;
                this.emit('walletAccountChanged', this);
                return;
            }
            await this.calcAccountData();
        });
        // Subscribe to chainId change
        this.provider?.on('chainChanged', async (chainId) => {
            await this.calcAccountData();
        });
        // Subscribe to session disconnection
        this.provider?.on('disconnect', async (code, reason) => {
            await this.calcAccountData();
        });
    }
    async connect() {
        if (this.isActivationInProgress) {
            return;
        }
        this.isActivationInProgress = true;
        // Reset provider for every connection attempt
        const walletConnectProvider = new WalletConnectProvider({
            rpc: this.options,
        });
        this.provider =
            walletConnectProvider;
        this.walletConnectProvider = walletConnectProvider;
        try {
            await this.walletConnectProvider?.enable(); // open modal
            this.startListening();
            await this.calcAccountData();
        }
        catch (e) {
            this.isActivationInProgress = false;
            throw e;
        }
        this.isActivationInProgress = false;
    }
    async disconnect() {
        if (this.provider) {
            await this.provider?.disconnect();
            await this.walletConnectProvider?.disconnect();
            this.provider = undefined;
            this.walletConnectProvider = undefined;
            this.isActivationInProgress = false;
            this.account = undefined;
            this.emit('walletAccountChanged', this);
        }
    }
    async switchChain(chainId) {
        if (!this.provider) {
            throw new Error('provider is not defined.');
        }
        return switchChain(this.provider, chainId);
    }
    async addChain(chainId) {
        if (!this.provider) {
            throw new Error('provider is not defined.');
        }
        return addChain(this.provider, chainId);
    }
    async addToken(chainId, token) {
        if (!this.provider) {
            throw new Error('provider is not defined.');
        }
        return switchChainAndAddToken(this.provider, chainId, token);
    }
    async calcAccountData() {
        if (!this.walletConnectProvider) {
            throw new Error('provider is not defined.');
        }
        const provider = new ethers.providers.Web3Provider(this.walletConnectProvider, 'any');
        const signer = provider.getSigner();
        this.account = {
            chainId: await signer.getChainId(),
            address: await signer.getAddress(),
            signer,
            provider,
        };
        this.emit('walletAccountChanged', this);
    }
}
