"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectConnector = void 0;
const ethereum_provider_1 = require("@walletconnect/ethereum-provider");
const ethers_1 = require("ethers");
const events_1 = require("events");
const walletAutomation_1 = require("../walletAutomation");
class WalletConnectConnector extends events_1.default.EventEmitter {
    constructor(constructorArgs) {
        super();
        this.isActivationInProgress = false;
        this.options = constructorArgs.rpc;
        this.name = constructorArgs.name;
        this.icon = constructorArgs.icon;
        this.installed = constructorArgs.installed;
    }
    async startListening() {
        // Subscribe to accounts change
        this.provider?.on('accountsChanged', async (accounts) => {
            if (!accounts.length) {
                this.account = undefined;
                this.emit('walletAccountChanged', this);
                return;
            }
            await this.calcAccountData();
        });
        // Subscribe to chainId change
        this.provider?.on('chainChanged', async (chainId) => {
            await this.calcAccountData();
        });
        // Subscribe to session disconnection
        this.provider?.on('disconnect', async (code, reason) => {
            await this.calcAccountData();
        });
    }
    async connect() {
        if (this.isActivationInProgress) {
            return;
        }
        this.isActivationInProgress = true;
        // Reset provider for every connection attempt
        const walletConnectProvider = new ethereum_provider_1.default({
            rpc: this.options,
        });
        this.provider =
            walletConnectProvider;
        this.walletConnectProvider = walletConnectProvider;
        try {
            await this.walletConnectProvider?.enable(); // open modal
            this.startListening();
            await this.calcAccountData();
        }
        catch (e) {
            this.isActivationInProgress = false;
            throw e;
        }
        this.isActivationInProgress = false;
    }
    async disconnect() {
        if (this.provider) {
            await this.provider?.disconnect();
            await this.walletConnectProvider?.disconnect();
            this.provider = undefined;
            this.walletConnectProvider = undefined;
            this.isActivationInProgress = false;
            this.account = undefined;
            this.emit('walletAccountChanged', this);
        }
    }
    async switchChain(chainId) {
        if (!this.provider) {
            throw new Error('provider is not defined.');
        }
        return (0, walletAutomation_1.switchChain)(this.provider, chainId);
    }
    async addChain(chainId) {
        if (!this.provider) {
            throw new Error('provider is not defined.');
        }
        return (0, walletAutomation_1.addChain)(this.provider, chainId);
    }
    async addToken(chainId, token) {
        if (!this.provider) {
            throw new Error('provider is not defined.');
        }
        return (0, walletAutomation_1.switchChainAndAddToken)(this.provider, chainId, token);
    }
    async calcAccountData() {
        if (!this.walletConnectProvider) {
            throw new Error('provider is not defined.');
        }
        const provider = new ethers_1.ethers.providers.Web3Provider(this.walletConnectProvider, 'any');
        const signer = provider.getSigner();
        this.account = {
            chainId: await signer.getChainId(),
            address: await signer.getAddress(),
            signer,
            provider,
        };
        this.emit('walletAccountChanged', this);
    }
}
exports.WalletConnectConnector = WalletConnectConnector;
