"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.switchChainAndAddToken = exports.addToken = exports.addChain = exports.switchChain = void 0;
const sdk_1 = require("@lifi/sdk");
const switchChain = async (provider, chainId) => {
    return new Promise((resolve, reject) => {
        try {
            provider
                .request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: (0, sdk_1.getChainById)(chainId).metamask?.chainId }],
            })
                .catch((error) => {
                if (error.code !== sdk_1.MetaMaskProviderErrorCode.userRejectedRequest) {
                    (0, exports.addChain)(provider, chainId).then((result) => resolve(result));
                }
                else {
                    reject(error);
                }
            });
            provider.once('chainChanged', (id) => {
                if (parseInt(id) === chainId) {
                    resolve(true);
                }
            });
        }
        catch (error) {
            // const ERROR_CODE_UNKNOWN_CHAIN = 4902
            if (error.code !== sdk_1.MetaMaskProviderErrorCode.userRejectedRequest) {
                (0, exports.addChain)(provider, chainId).then((result) => resolve(result));
            }
            else {
                console.error(error);
                resolve(false);
            }
        }
    });
};
exports.switchChain = switchChain;
const addChain = async (provider, chainId) => {
    const params = (0, sdk_1.getChainById)(chainId).metamask;
    try {
        await provider.request({
            method: 'wallet_addEthereumChain',
            params: [params],
        });
        return true;
    }
    catch (error) {
        console.error(`Error adding chain ${chainId}: ${error.message}`);
    }
    return false;
};
exports.addChain = addChain;
const addToken = async (provider, token) => {
    try {
        // wasAdded is a boolean. Like any RPC method, an error may be thrown.
        const wasAdded = await provider.request({
            method: 'wallet_watchAsset',
            params: {
                type: 'ERC20',
                options: {
                    address: token.address,
                    symbol: token.symbol,
                    decimals: token.decimals,
                    image: token.logoURI, // A string url of the token logo
                },
            },
        });
        return wasAdded;
    }
    catch (error) {
        console.error(error);
    }
    return false;
};
exports.addToken = addToken;
const switchChainAndAddToken = async (provider, chainId, token) => {
    const chainIdPrefixed = (0, sdk_1.prefixChainId)(chainId);
    try {
        if (chainIdPrefixed !== provider.chainId) {
            await (0, exports.switchChain)(provider, chainId);
            provider.once('chainChanged', async (id) => {
                if (parseInt(id, 10) === chainId) {
                    await (0, exports.addToken)(provider, token);
                }
            });
        }
        else {
            await (0, exports.addToken)(provider, token);
        }
        return true;
    }
    catch (e) {
        console.error(e);
        return false;
    }
};
exports.switchChainAndAddToken = switchChainAndAddToken;
