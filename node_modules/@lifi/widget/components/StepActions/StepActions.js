import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import { Badge, Box, Collapse, Step as MuiStep, Stepper, Typography, } from '@mui/material';
import Big from 'big.js';
import { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { useChains } from '../../hooks';
import { LiFiToolLogo } from '../../icons';
import { useWidgetConfig } from '../../providers';
import { formatTokenAmount } from '../../utils';
import { CardIconButton } from '../Card';
import { SmallAvatar } from '../SmallAvatar';
import { StepAvatar, StepConnector, StepContent, StepLabel, } from './StepActions.style';
export const StepActions = ({ step, dense, ...other }) => {
    const { t } = useTranslation();
    const { variant, contractTool } = useWidgetConfig();
    const [cardExpanded, setCardExpanded] = useState(false);
    const handleExpand = (e) => {
        e.stopPropagation();
        setCardExpanded((expanded) => !expanded);
    };
    const customStep = variant === 'nft'
        ? step.includedSteps?.find((step) => step.type === 'custom')
        : undefined;
    const hasCollapsedSteps = dense && step.includedSteps?.length > 1;
    if (customStep && contractTool) {
        const toolDetails = {
            key: contractTool.name,
            name: contractTool.name,
            logoURI: contractTool.logoURI,
        };
        customStep.toolDetails = toolDetails;
        if (dense) {
            step.toolDetails = toolDetails;
        }
    }
    return (_jsxs(Box, { ...other, children: [_jsxs(Box, { display: "flex", alignItems: "center", children: [_jsx(Badge, { overlap: "circular", anchorOrigin: { vertical: 'bottom', horizontal: 'right' }, badgeContent: _jsx(SmallAvatar, { children: _jsx(LiFiToolLogo, {}) }), children: _jsx(StepAvatar, { variant: "circular", src: step.toolDetails.logoURI, alt: step.toolDetails.name, children: step.toolDetails.name[0] }) }), _jsx(Typography, { ml: 2, fontSize: 18, fontWeight: "500", flex: 1, children: t(`swap.stepDetails`, {
                            tool: step.toolDetails.name,
                        }) }), hasCollapsedSteps ? (_jsx(CardIconButton, { onClick: handleExpand, size: "small", children: cardExpanded ? _jsx(ExpandLessIcon, {}) : _jsx(ExpandMoreIcon, {}) })) : null] }), hasCollapsedSteps ? (_jsx(Collapse, { timeout: 225, in: cardExpanded, mountOnEnter: true, unmountOnExit: true, children: _jsx(IncludedSteps, { step: step, variant: variant }) })) : (_jsx(IncludedSteps, { step: step, variant: variant }))] }));
};
export const IncludedSteps = ({ step, variant }) => {
    // eslint-disable-next-line react/no-unstable-nested-components
    const StepIconComponent = ({ icon }) => {
        const tool = step.includedSteps?.[Number(icon) - 1];
        return tool ? (_jsx(SmallAvatar, { src: tool.toolDetails.logoURI, alt: tool.toolDetails.name, sx: {
                boxSizing: 'content-box',
            }, children: tool.toolDetails.name[0] })) : null;
    };
    const StepDetailsLabel = step.tool === 'custom' && variant === 'nft'
        ? CustomStepDetailsLabel
        : step.type === 'lifi' &&
            step.includedSteps.some((step) => step.type === 'cross')
            ? CrossStepDetailsLabel
            : SwapStepDetailsLabel;
    return step.includedSteps.length > 1 ? (_jsx(Box, { mt: 1.5, children: _jsx(Stepper, { orientation: "vertical", connector: _jsx(StepConnector, {}), activeStep: -1, children: step.includedSteps.map((step, i) => (_jsxs(MuiStep, { expanded: true, children: [_jsx(StepLabel, { StepIconComponent: StepIconComponent, children: step.type === 'custom' && variant === 'nft' ? (_jsx(CustomStepDetailsLabel, { step: step, variant: variant })) : step.type === 'cross' ? (_jsx(CrossStepDetailsLabel, { step: step })) : step.type === 'protocol' ? (_jsx(ProtocolStepDetailsLabel, { step: step })) : (_jsx(SwapStepDetailsLabel, { step: step })) }), _jsx(StepContent, { children: _jsx(StepDetailsContent, { step: step, variant: variant }) })] }, step.id))) }) })) : (_jsxs(Box, { ml: 6, children: [_jsx(StepDetailsLabel, { step: step, variant: variant === 'nft' ? variant : undefined }), _jsx(StepDetailsContent, { step: step, variant: variant })] }));
};
export const StepDetailsContent = ({ step, variant }) => {
    const { t } = useTranslation();
    const sameTokenProtocolStep = step.action.fromToken.chainId === step.action.toToken.chainId &&
        step.action.fromToken.address === step.action.toToken.address;
    let fromAmount;
    if (sameTokenProtocolStep) {
        fromAmount = Big(step.estimate.fromAmount)
            .div(10 ** step.action.fromToken.decimals)
            .minus(Big(step.estimate.toAmount).div(10 ** step.action.toToken.decimals));
    }
    else {
        fromAmount = formatTokenAmount(step.estimate.fromAmount, step.action.fromToken.decimals);
    }
    const showToAmount = step.type !== 'custom' &&
        step.tool !== 'custom' &&
        variant !== 'nft' &&
        !sameTokenProtocolStep;
    return (_jsxs(Typography, { fontSize: 12, fontWeight: "500", color: "text.secondary", alignItems: "center", display: "flex", children: [t('format.number', {
                value: fromAmount,
            }), ' ', step.action.fromToken.symbol, showToAmount ? (_jsxs(_Fragment, { children: [_jsx(ArrowForwardIcon, { sx: { fontSize: 18, paddingX: 0.5 } }), t('format.number', {
                        value: formatTokenAmount(step.execution?.toAmount ?? step.estimate.toAmount, step.execution?.toToken?.decimals ?? step.action.toToken.decimals),
                    }), ' ', step.execution?.toToken?.symbol ?? step.action.toToken.symbol] })) : null] }));
};
export const CustomStepDetailsLabel = ({ step, variant, }) => {
    const { t } = useTranslation();
    if (!variant) {
        return null;
    }
    return (_jsx(Typography, { fontSize: 12, fontWeight: "500", color: "text.secondary", children: t(`swap.${variant}StepDetails`, {
            tool: step.toolDetails.name,
        }) }));
};
export const CrossStepDetailsLabel = ({ step }) => {
    const { t } = useTranslation();
    const { getChainById } = useChains();
    return (_jsx(Typography, { fontSize: 12, fontWeight: "500", color: "text.secondary", children: t('swap.crossStepDetails', {
            from: getChainById(step.action.fromChainId)?.name,
            to: getChainById(step.action.toChainId)?.name,
            tool: step.toolDetails.name,
        }) }));
};
export const SwapStepDetailsLabel = ({ step }) => {
    const { t } = useTranslation();
    const { getChainById } = useChains();
    return (_jsx(Typography, { fontSize: 12, fontWeight: "500", color: "text.secondary", children: t('swap.swapStepDetails', {
            chain: getChainById(step.action.fromChainId)?.name,
            tool: step.toolDetails.name,
        }) }));
};
export const ProtocolStepDetailsLabel = ({ step }) => {
    const { t } = useTranslation();
    return (_jsx(Typography, { fontSize: 12, fontWeight: "500", color: "text.secondary", children: step.toolDetails.key === 'lifuelProtocol'
            ? t('swap.refuelStepDetails', {
                tool: step.toolDetails.name,
            })
            : step.toolDetails.name }));
};
