"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAccountFromSigner = exports.WalletProvider = exports.useWallet = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const wallet_management_1 = require("@lifi/wallet-management");
const react_1 = require("react");
const WidgetProvider_1 = require("../WidgetProvider");
const liFiWalletManagement = new wallet_management_1.LiFiWalletManagement();
const stub = () => {
    throw new Error(`You forgot to wrap your component in <${exports.WalletProvider.name}>.`);
};
const initialContext = {
    connect: stub,
    disconnect: stub,
    switchChain: stub,
    addChain: stub,
    addToken: stub,
    account: {},
};
const WalletContext = (0, react_1.createContext)(initialContext);
const useWallet = () => (0, react_1.useContext)(WalletContext);
exports.useWallet = useWallet;
const WalletProvider = ({ children }) => {
    const { walletManagement } = (0, WidgetProvider_1.useWidgetConfig)();
    const [account, setAccount] = (0, react_1.useState)({});
    const [currentWallet, setCurrentWallet] = (0, react_1.useState)();
    (0, react_1.useEffect)(() => {
        const autoConnect = async () => {
            const persistedActiveWallets = (0, wallet_management_1.readActiveWallets)();
            const activeWallets = wallet_management_1.supportedWallets.filter((wallet) => persistedActiveWallets.some((perstistedWallet) => perstistedWallet.name === wallet.name));
            if (!activeWallets.length) {
                return;
            }
            await liFiWalletManagement.autoConnect(activeWallets);
            activeWallets[0].on('walletAccountChanged', handleWalletUpdate);
            handleWalletUpdate(activeWallets[0]);
        };
        autoConnect();
    }, []);
    const handleWalletUpdate = async (wallet) => {
        setCurrentWallet(wallet);
        const account = await (0, exports.extractAccountFromSigner)(wallet?.account?.signer);
        setAccount(account);
    };
    const connect = (0, react_1.useCallback)(async (wallet) => {
        if (walletManagement) {
            const signer = await walletManagement.connect();
            const account = await (0, exports.extractAccountFromSigner)(signer);
            setAccount(account);
            return;
        }
        await liFiWalletManagement.connect(wallet);
        wallet.on('walletAccountChanged', handleWalletUpdate);
        handleWalletUpdate(wallet);
    }, [walletManagement]);
    const disconnect = (0, react_1.useCallback)(async () => {
        if (walletManagement) {
            await walletManagement.disconnect();
            setAccount({});
            return;
        }
        if (currentWallet) {
            await liFiWalletManagement.disconnect(currentWallet);
            currentWallet.removeAllListeners();
            handleWalletUpdate(undefined);
        }
    }, [walletManagement, currentWallet]);
    const switchChain = (0, react_1.useCallback)(async (chainId) => {
        if (walletManagement?.switchChain) {
            const signer = await walletManagement.switchChain(chainId);
            const account = await (0, exports.extractAccountFromSigner)(signer);
            setAccount(account);
            return true;
        }
        try {
            await currentWallet?.switchChain(chainId);
            handleWalletUpdate(currentWallet);
            return true;
        }
        catch {
            return false;
        }
    }, [walletManagement, currentWallet]);
    const addChain = (0, react_1.useCallback)(async (chainId) => {
        if (walletManagement?.addChain) {
            return walletManagement.addChain(chainId);
        }
        try {
            await currentWallet?.addChain(chainId);
            handleWalletUpdate(currentWallet);
            return true;
        }
        catch {
            return false;
        }
    }, [walletManagement, currentWallet]);
    const addToken = (0, react_1.useCallback)(async (chainId, token) => {
        if (walletManagement?.addToken) {
            return walletManagement.addToken(token, chainId);
        }
        await currentWallet?.addToken(chainId, token);
        handleWalletUpdate(currentWallet);
        return;
    }, [walletManagement, currentWallet]);
    // keep widget in sync with changing external signer object
    (0, react_1.useEffect)(() => {
        if (walletManagement) {
            const updateAccount = async () => {
                const account = await (0, exports.extractAccountFromSigner)(walletManagement?.signer);
                setAccount(account);
            };
            updateAccount();
        }
    }, [walletManagement, walletManagement?.signer]);
    const value = (0, react_1.useMemo)(() => ({
        connect,
        disconnect,
        switchChain,
        addChain,
        addToken,
        account,
        provider: currentWallet?.account?.provider,
    }), [
        account,
        addChain,
        addToken,
        connect,
        disconnect,
        currentWallet,
        switchChain,
    ]);
    return ((0, jsx_runtime_1.jsx)(WalletContext.Provider, { value: value, children: children }));
};
exports.WalletProvider = WalletProvider;
const extractAccountFromSigner = async (signer) => {
    try {
        return {
            address: await signer?.getAddress(),
            isActive: (signer && !!(await signer.getAddress()) === null) || !!signer,
            signer,
            chainId: await signer?.getChainId(),
        };
    }
    catch (error) {
        console.error(error);
        return {};
    }
};
exports.extractAccountFromSigner = extractAccountFromSigner;
